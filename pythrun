#!/usr/bin/env python3

# source: https://github.com/BrassTack/pythrun

# This is free and unencumbered software released into the public domain.
#
# Anyone is free to copy, modify, publish, use, compile, sell, or
# distribute this software, either in source code form or as a compiled
# binary, for any purpose, commercial or non-commercial, and by any
# means.
#
# In jurisdictions that recognize copyright laws, the author or authors
# of this software dedicate any and all copyright interest in the
# software to the public domain. We make this dedication for the benefit
# of the public at large and to the detriment of our heirs and
# successors. We intend this dedication to be an overt act of
# relinquishment in perpetuity of all present and future rights to this
# software under copyright law.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# For more information, please refer to <http://unlicense.org/>


import os
import sys
import pty
import venv
import subprocess
import ast
import importlib.util

def parse_imports(file_path):
    try:
        with open(file_path, 'r') as file:
            tree = ast.parse(file.read())
    except SyntaxError as e:
        print(f"SyntaxError in file {file_path}: {e}", flush=True)
        print(f"Line in file with error: {e.text.strip()}\n{' ' * (e.offset - 1)}^", flush=True)
        sys.exit(1)

    imports = set()
    for node in ast.walk(tree):
        if isinstance(node, ast.Import):
            for alias in node.names:
                imports.add(alias.name.split('.')[0])
        elif isinstance(node, ast.ImportFrom):
            if node.module:
                imports.add(node.module.split('.')[0])

    return imports

def create_venv(venv_path):
    venv.create(venv_path, with_pip=True, system_site_packages=True)

def is_module_available(module_name):
    return importlib.util.find_spec(module_name) is not None

def install_dependencies(venv_path, dependencies):
    pip_path = os.path.join(venv_path, 'bin', 'pip')
    failed_installs = []
    for dep in dependencies:
        dep_mapping = {
            'yaml': 'pyyaml',
        }
        dep = dep_mapping.get(dep, dep)
        if not is_module_available(dep):
            try:
                subprocess.run([pip_path, 'install', dep], check=True, capture_output=True, text=True)
                print(f"Successfully installed {dep}", flush=True)
            except subprocess.CalledProcessError as e:
                print(f"Failed to install {dep}. Error: {e.stderr.strip()}", flush=True)
                failed_installs.append(dep)
        else:
            print(f"Module {dep} is already available. Skipping installation.", flush=True)

    return failed_installs

def run_script(venv_path, script_path, args):
    python_path = os.path.join(venv_path, 'bin', 'python')
    full_command = [python_path, '-u', script_path] + args  # Add '-u' for unbuffered output
    print(f"pythrun: Starting execution of {script_path}", flush=True)
    print(f"pythrun: Full command: {' '.join(full_command)}", flush=True)

    try:
        print("--- Begin script output ---", flush=True)

        # Capture both stdout and stderr in the same stream to maintain order
        process = subprocess.run(full_command, stderr=subprocess.STDOUT)

        print("--- End script output ---", flush=True)

        print(f"pythrun: Script {script_path} completed. Exit code: {process.returncode}", flush=True)
        if process.returncode != 0:
            print(f"pythrun: Warning: Script exited with non-zero status.", flush=True)
        return process.returncode
    except KeyboardInterrupt:
        print("\npythrun: Script execution interrupted by user.", flush=True)
        return 1
    except Exception as e:
        print(f"pythrun: An unexpected error occurred: {e}", flush=True)
        return 1


def main():
    try:
        if len(sys.argv) < 2:
            print("Usage: pythrun <script.py> [script arguments...]", flush=True)
            sys.exit(1)

        script_path = sys.argv[1]
        script_args = sys.argv[2:]
        script_dir = os.path.dirname(os.path.abspath(script_path))
        venv_path = os.path.join(script_dir, '.venv')

        if not os.path.exists(venv_path):
            create_venv(venv_path)

        dependencies = set()

        requirements_path = os.path.join(script_dir, 'requirements.txt')
        if os.path.exists(requirements_path):
            with open(requirements_path, 'r') as req_file:
                dependencies.update(line.strip() for line in req_file if line.strip())

        dependencies.update(parse_imports(script_path))
        dependencies = {dep for dep in dependencies if dep}

        failed_installs = install_dependencies(venv_path, dependencies)

        if failed_installs:
            print(f"Failed to install the following packages: {', '.join(failed_installs)}", flush=True)
            print("The script may not run correctly.", flush=True)
            user_input = input("Do you want to continue anyway? (y/n): ").lower()
            if user_input != 'y':
                print("Aborting script execution.", flush=True)
                sys.exit(1)

        print("pythrun: Dependency installation complete. Running the script...", flush=True)
        exit_code = run_script(venv_path, script_path, script_args)
        sys.exit(exit_code)
    except KeyboardInterrupt:
        print("\npythrun: Execution interrupted by user.", flush=True)
        sys.exit(1)

if __name__ == "__main__":
    main()
