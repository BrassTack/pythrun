#!/usr/bin/env python3

# source: https://github.com/BrassTack/pythrun

# This is free and unencumbered software released into the public domain.
#
# Anyone is free to copy, modify, publish, use, compile, sell, or
# distribute this software, either in source code form or as a compiled
# binary, for any purpose, commercial or non-commercial, and by any
# means.
#
# In jurisdictions that recognize copyright laws, the author or authors
# of this software dedicate any and all copyright interest in the
# software to the public domain. We make this dedication for the benefit
# of the public at large and to the detriment of our heirs and
# successors. We intend this dedication to be an overt act of
# relinquishment in perpetuity of all present and future rights to this
# software under copyright law.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# For more information, please refer to <http://unlicense.org/>

import os
import sys
import venv
import subprocess
import ast
import importlib.util
import json
import hashlib
import time
import argparse

CACHE_FILE_NAME = 'imports_cache.txt'
METADATA_FILE_NAME = 'metadata.json'

# Log function for general (verbose) output
def log(message):
    if not QUIET_MODE:
        print(message, flush=True)

# Log function for critical output (always shown)
def log_always(message):
    print(message, flush=True)

def get_venv_path(script_path):
    hashed_script_path = hashlib.md5(script_path.encode()).hexdigest()
    base_venv_dir = os.getenv('PYTHRUN_VENVS_DIR', os.path.expanduser('~/.pythrun_venvs'))
    return os.path.join(base_venv_dir, hashed_script_path)

def create_metadata_file(venv_path, script_path):
    metadata = {
        'script_path': script_path,
        'created_at': time.strftime('%Y-%m-%d %H:%M:%S')
    }
    metadata_file = os.path.join(venv_path, METADATA_FILE_NAME)
    with open(metadata_file, 'w') as f:
        json.dump(metadata, f)

def load_cached_imports(cache_file):
    if not os.path.exists(cache_file):
        return set()
    
    with open(cache_file, 'r') as f:
        cached_imports = json.load(f)
    return set(cached_imports)

def save_cached_imports(cache_file, imports):
    with open(cache_file, 'w') as f:
        json.dump(list(imports), f)

def parse_imports(file_path):
    try:
        with open(file_path, 'r') as file:
            tree = ast.parse(file.read())
    except SyntaxError as e:
        log_always(f"SyntaxError in file {file_path}: {e}")
        log_always(f"Line in file with error: {e.text.strip()}\n{' ' * (e.offset - 1)}^")
        sys.exit(1)
    
    imports = set()
    for node in ast.walk(tree):
        if isinstance(node, ast.Import):
            for alias in node.names:
                imports.add(alias.name.split('.')[0])
        elif isinstance(node, ast.ImportFrom):
            if node.module:
                imports.add(node.module.split('.')[0])
    
    return imports

def create_venv(venv_path):
    venv.create(venv_path, with_pip=True, system_site_packages=True)

def is_module_available(module_name):
    return importlib.util.find_spec(module_name) is not None

def install_dependencies(venv_path, dependencies):
    pip_path = os.path.join(venv_path, 'bin', 'pip')
    failed_installs = []
    for dep in dependencies:
        dep_mapping = {
            'yaml': 'pyyaml',
        }
        dep = dep_mapping.get(dep, dep)
        if not is_module_available(dep):
            try:
                subprocess.run([pip_path, 'install', dep], check=True, capture_output=True, text=True)
                log_always(f"Successfully installed {dep}")
            except subprocess.CalledProcessError as e:
                log_always(f"Failed to install {dep}. Error: {e.stderr.strip()}")
                failed_installs.append(dep)
        else:
            log(f"Module {dep} is already available. Skipping installation.")
    
    return failed_installs

def run_script(venv_path, script_path, args):
    python_path = os.path.join(venv_path, 'bin', 'python')
    full_command = [python_path, '-u', script_path] + args
    log(f"pythrun: Starting execution of {script_path}")
    log_always(f"pythrun: Full command: {' '.join(full_command)}")

    try:
        log_always("--- Begin output ---")

        process = subprocess.run(full_command, stderr=subprocess.STDOUT)

        log_always("--- End output ---")

        log(f"pythrun: Script {script_path} completed. Exit code: {process.returncode}")
        if process.returncode != 0:
            log_always(f"pythrun: Warning: Script exited with non-zero status. Exit code: {process.returncode}")
        return process.returncode
    except KeyboardInterrupt:
        log_always("\npythrun: Script execution interrupted by user.")
        return 1
    except Exception as e:
        log_always(f"pythrun: An unexpected error occurred: {e}")
        return 1

def main():
    global QUIET_MODE

    parser = argparse.ArgumentParser(description="Run Python scripts with virtualenv and dependency management.")
    parser.add_argument('script', help="Path to the Python script to run")
    parser.add_argument('script_args', nargs=argparse.REMAINDER, help="Arguments to pass to the script")
    parser.add_argument('-q', '--quiet', action='store_true', help="Suppress non-active output")

    args = parser.parse_args()
    QUIET_MODE = args.quiet

    script_path = os.path.abspath(args.script)
    script_args = args.script_args
    venv_path = get_venv_path(script_path)
    cache_file = os.path.join(venv_path, CACHE_FILE_NAME)

    if not os.path.exists(venv_path):
        log_always(f"Creating virtual environment at {venv_path}")
        create_venv(venv_path)
        create_metadata_file(venv_path, script_path)

    # Load cached imports
    cached_imports = load_cached_imports(cache_file)

    # Parse current imports
    current_imports = parse_imports(script_path)

    # Only install dependencies if imports have changed
    if current_imports != cached_imports:
        log_always("pythrun: Detected new or changed imports. Installing dependencies...")
        failed_installs = install_dependencies(venv_path, current_imports)
        if failed_installs:
            log_always(f"Failed to install the following packages: {', '.join(failed_installs)}")
            log_always("The script may not run correctly.")
            user_input = input("Do you want to continue anyway? (y/n): ").lower()
            if user_input != 'y':
                log_always("Aborting script execution.")
                sys.exit(1)
        # Save the updated imports to cache
        save_cached_imports(cache_file, current_imports)
    else:
        log("pythrun: No new imports detected. Skipping dependency installation.")

    log("pythrun: Dependency installation complete. Running the script...")
    exit_code = run_script(venv_path, script_path, script_args)
    sys.exit(exit_code)

if __name__ == "__main__":
    main()

